# to generate coredump at segfault
# ensure the following is done:
  ulimit -c unlimited  # ensures enough memory for generating coredump
  sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t  # describes the pathname of the generated core file
# The above will generate a coredump if your own program does not have a SIGSEGV handler implementd

# To print the stack trace you should have a SIGSEGV handler implemented

# To make sense of the coredump use the command
  gdb  ./stacks_and_dumps /tmp/<executable_name>.<pid>.<hostname>.<timestamp>
 
# If print_stack_trace is enabled it will print the stacktrace somthing like this
  [root@k8s-master print_stack_trace]# ./stacks_and_dumps
  Error: signal 11:
  ./stacks_and_dumps(handler+0x25)[0x400a32]
  /lib64/libc.so.6(+0x36400)[0x7f50007ef400]
  ./stacks_and_dumps(yet_another_func+0x46)[0x400aff]
  ./stacks_and_dumps(another_func+0x12)[0x400a9f]
  ./stacks_and_dumps(a_func+0xe)[0x400a8b]
  ./stacks_and_dumps(main+0x28)[0x400b40]
  /lib64/libc.so.6(__libc_start_main+0xf5)[0x7f50007db555]
  ./stacks_and_dumps[0x400949]

# How coredump is generated by kernel
  # When SIGSEGV is generated the kernel checks if you have written a handler for it
  # If yes, the kernel let's the handler take care of the rest

  # If no, it will try to generate coredump by calling 
    void do_coredump(const kernel_siginfo_t *siginfo)
  # in the defined in the file 
    fs/coredump.c
